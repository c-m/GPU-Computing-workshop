#include "Utils.h"

// ===============
// The CUDA kernel
// ===============

__global__ void deviceAddKernel(
	const float * const __restrict__ d_a,
	const float * const __restrict__ d_b,
	float * const __restrict__ d_c,
	const int vSize)
{
	int gIdx = blockIdx.x * blockDim.x + threadIdx.x;

	if(gIdx >= vSize)
	{
		return;
	}

	d_c[gIdx] = d_a[gIdx] + d_b[gIdx];
}


// ===========================================
// Add vectors on the CPU and measure the time
// ===========================================

float hostAdd(const float * h_a, const float * h_b, float * h_c, const int vSize)
{
	long long start;
	float freq;

	hostTimerStart(&freq, &start);
	
	for(int i = 0; i < vSize; ++i)
	{
		h_c[i] = h_a[i] + h_b[i];
	}

	return hostTimerStop(freq, start);
}

// ===========================================
// Add vectors on the GPU and measure the time
// ===========================================

float deviceAdd(const float * h_a, const float * h_b, float * h_c, int vSize,
	int nBlocks, int nThreadsPerBlock)
{
	float * d_a = NULL;
	float * d_b = NULL;
	float * d_c = NULL;
	const int byteSize = vSize * sizeof(float);
	cudaEvent_t start,stop;
	float time;

	SAFE_CUDA_CALL(cudaEventCreate(&start));
	SAFE_CUDA_CALL(cudaEventCreate(&stop));

	generateDeviceData(byteSize, &d_a, h_a, TRUE);
	generateDeviceData(byteSize, &d_b, h_b, TRUE);
	generateDeviceData(byteSize, &d_c, NULL, FALSE);

	SAFE_CUDA_CALL(cudaEventRecord(start, 0));
	deviceAddKernel<<<nBlocks, nThreadsPerBlock>>>(d_a, d_b, d_c, vSize);
	SAFE_CUDA_CALL(cudaEventRecord(stop, 0));
	SAFE_CUDA_CALL(cudaEventSynchronize(stop));

	SAFE_CUDA_CALL(cudaEventElapsedTime(&time, start, stop));

	/*SAFE_CUDA_CALL(cudaDeviceSynchronize());*/
	//daca ajunge sa se execute cudaMemcpy sigur deviceAddKernel a terminat de executat
	
	SAFE_CUDA_CALL(cudaMemcpy(h_c, d_c, byteSize, cudaMemcpyDeviceToHost));

	SAFE_CUDA_CALL(cudaFree(d_a));
	SAFE_CUDA_CALL(cudaFree(d_b));
	SAFE_CUDA_CALL(cudaFree(d_c));
	SAFE_CUDA_CALL(cudaEventDestroy(start));
	SAFE_CUDA_CALL(cudaEventDestroy(stop));

	return time * 1000.0F;
}
// =======================
// Application entry point
// =======================

int _02_Vector_Add(int argCount, char ** argValues)
{
	int vGridConf[3];	// The grid configuration
	float * h_a = NULL;		// Host input array A
	float * h_b = NULL;		// Host input array B
	float * h_c_h = NULL;	// Host output array C as generated by the host
	float * h_c_d = NULL;	// Host output array C as generated by the device
	float hostTime, devTime;
	const char * vErrMessages[2] =	{"Error: The number of threads must be greater than 0.",
									 "Error: The array size must be greater than 0."};

	// Validate the command-line arguments
	validateArguments(argCount, 2, argValues, vGridConf, vErrMessages);

	// Generate the host-based data
	generateHostData(vGridConf[2], &h_a, TRUE);		// Input array A
	generateHostData(vGridConf[2], &h_b, TRUE);		// Input array B
	generateHostData(vGridConf[2], &h_c_h, FALSE);	// Output host array C generated by the host		
	generateHostData(vGridConf[2], &h_c_d, FALSE);	// Output host array C generated by the device

	printf("Data generation complete." NEW_LINE);

	// Perform the host-based addition
	hostTime = hostAdd(h_a, h_b, h_c_h, vGridConf[2]);

	printf("Host addition time: %.2f us" NEW_LINE, hostTime);
	printf("Will launch (B: %d, T: %d, G: %d):" NEW_LINE, vGridConf[0], vGridConf[1], vGridConf[2]);

	// Perfrm the device-based addition
	devTime = deviceAdd(h_a, h_b, h_c_d, vGridConf[2], vGridConf[0], vGridConf[1]);

	printf("Device addition time: %.2f us" NEW_LINE, devTime);

	// Compute the speed-up between the device and the host
	printf("Speed-up: %.2f" NEW_LINE, hostTime / devTime);

	// Check if the calculated arrays match
	compareResults(h_c_h, h_c_d, vGridConf[2]);

	// Free host memory
	free(h_a);
	free(h_b);
	free(h_c_h);
	free(h_c_d);
	
	WAIT_AND_EXIT(0);
}